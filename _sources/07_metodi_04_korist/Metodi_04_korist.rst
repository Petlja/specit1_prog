Корист од метода
================

До сада смо научили како се методи пишу и како се извршавају. Успут смо видели и неколико примера употребе метода. Такође смо видели да се задатак у коме смо користили метод може решити и без коришћења метода. Због тога се дешава да у току учења програмирања одлажемо учење метода, јер се без њих може. Овде желимо да вам јасно скренемо пажњу да је овакав приступ погрешан - **немојте одлагати учење метода!** 

Можда сте себи већ поставили питање: шта ја добијам тиме што користим методе? Питање је сасвим на месту и у наставку ћемо покушати да дамо одговор на њега. Одговор је нешто дужи и детаљнији, јер ово питање сматрамо важним, а разлози за коришћење метода нису сами по себи једнако јасни као, рецимо, за коришћење ``for`` наредбе. Евентуалну дилему око употребе метода треба решити на време, јер се добре навике најлакше (најмање тешко) усвајају и развијају увођењем од самог почетка - док нисмо навикли другачије.

Зашто треба писати методе
-------------------------

**Разлагање проблема:** Понекад је проблем који решавамо сложен и потребно нам је да га разложимо на делове који су мање сложени. Ово разлагање се може наставити до нивоа који нам је потребан. Након тога, сваки од делова можемо да решимо писањем одговарајућих метода, а затим позивањем написаних метода решавамо сложеније проблеме, све до полазног проблема. Овај приступ ће постајати све важнији, јер ћемо решавати све сложеније проблеме и писати све дуже програме.

**Јасније нама и другима:** Наше програме нећемо читати само ми, него и други људи. Зато треба да се трудимо да пишемо програме што јасније, а употреба метода у томе помаже. Чак и када је нама јасно како неки дугачак програм ради, вреди неке логичке целине издвојити у методе, јер тиме програм постаје јаснији и другима. На пример, програм се лакше разуме ако се у њему смањи број уметања наредби гранања и петљи једне у друге, тј. ако се смањи "дубина" програма тако што "најдубљи" део издвојимо у метод.

**Поновна употребљивост:** Писањем метода олакшавамо употребу истог кода и у другим програмима. Написани методи се могу издвојити у посебан модул, који затим ми, или други програмери, лако укључујемо у нове пројекте.

**Боља организација:** Код веома великих програма, формирањем метода омогућавамо да се програм распореди у више фајлова, уместо да се памти као један огроман и непрегледан фајл.

**Избегавање понављања:** Методи могу да нам помогну да избегнемо понављање истог или сличног кода у програмима. Понављање кода треба избегавати јер се такав код теже одржава. То значи да, кад накнадно треба да изменимо програм, сваку такву измену треба унети на више места, што је заморно и подложно грешкама и пропустима. Многи програмери, а нарочито почетници, подлегну искушењу да копирају (и ако је потребно, мало прилагоде) код који им је потребан на више места, уместо да од њега направе метод. Када нам део кода први пут затреба на још једном месту, обично потцењујемо шансе да нам тај код касније треба и на трећем или четвртом месту. Осим тога, врло често потцењујемо и проблеме који настају копирањем кода:

- Често не размишљамо о томе да ће бити потребно да се код мења, јер ми не намеравамо да га мењамо. Не заваравајте се! Потреба за изменом кода се често јавља, било због исправљања уочених грешака, било због нових захтева (нпр. решавамо сличан задатак почевши од програма претходног задатака). Пишите програме са свешћу о томе да ћете их мењати (ви или неко други). Ово значи да треба да настојите да пишете програме који се лако мењају, а избегавање понављања кода доприноси лакшем мењању.
- У дужем програму у коме се понављају слични делови лакше можемо да се дезоријентишемо и, мислећи да смо на неком другом месту у програму, почнемо да га преправљамо на начин који не одговара том месту. Можда вам се ово већ догодило?
- На једном програму често ради више људи. Чак и ако ми знамо који делови програма треба да остану исти, пре или касније се појави неко ко не зна. Тај неко може, исправљајући уочену грешку, унети промену на само једном месту (или на неколико, али не на свим местима). Касније, када видимо да су копирани делови програма постали различити, потребно је да уложимо додатан труд и време да установимо како је дошло до разлика и која "копија" је у добром стању, а која није (при том је могуће је да више није ниједна). Тада је прелазак на методе тежи него што је претходно био и оно што смо на почетку уштедели копирањем кода, касније вишеструко плаћамо.

Примери
-------

.. questionnote::

    **Исти збир цифара**
    
    Написати програм који учитава два броја и одговара на питање да ли та два броја имају исти збир цифара.
    
У решењу збир цифара датог броја одређујемо помоћу метода ``ZbirCifara``, који затим два пута позивамо.

.. activecode:: metodi_isti_zbir_cifara
    :passivecode: true
    :coach:
    :includesrc: _src/metodi/metodi_isti_zbir_cifara.cs

На овај начин смо избегли да наредбе за одређивање збира цифара пишемо два пута. Програм би био разумљив и да смо поновили један његов део, али овде смо се држали принципа да је понављање кода лоша пракса (разлози су наведени горе).

|

.. questionnote::

    **Домине**
    
    Домина има два поља, а на сваком пољу неколико тачака које представљају цифру. Када се две такве домине ставе једна до друге, 4 цифре у низу могу да се прочитају као један број. Домине могу да замене места и да се окрену, а потребно је добити што већи број.
    
    Написати програм који учитава 4 цифре представљене пољима двеју домина, а исписује највећи број који може да се добије стављањем тих домина једну уз другу.

Сваку домину треба окренути тако да поље са више тачака буде лево, а са мање десно. Овај потпроблем можемо да решимо помоћу метода који прима два једноцифрена броја као аргументе, а враћа већи двоцифрен број, од два која се могу формирати од датих цифара.

Када окренемо домине како треба, потребно је одредити прави редослед. Овај део проблема је сличан претходном, али сада од два двоцифрена броја треба направити већи четвороцифрени број.

Приметимо да се оба ова проблема могу схватити као специјални случајеви једног општијег проблема: дата су два броја која треба надовезати један на други, тако да се добије већи резултат. Због тога оба проблема можемо да решимо истим методом, који ће као аргументе добити та два броја која треба да надовеже. У случају надовезивања једноцифрених бројева, резултат се добија множењем веће цифре са 10 и додавањем мање, а код спајања двоцифрених бројева, већи од њих треба помножити са 100 пре сабирања са мањим. Да бисмо оба проблема што једноставније решили истим методом, увешћемо и трећи аргумент, који представља тежинску вредност већег од два броја која спајамо. Та тежинска вредност ће у једном случају бити 10 а у другом 100.


.. activecode:: metodi_domine_da
    :passivecode: true
    :coach:
    :includesrc: _src/metodi/metodi_domine_da.cs

|

Проблем смо, наравно, могли да решимо и без употребе метода, као у следећем решењу.

.. activecode:: metodi_domine_ne1
    :passivecode: true
    :coach:
    :includesrc: _src/metodi/metodi_domine_ne1.cs

Када проблем решавамо на такав начин, обично делове кода копирамо и затим преправимо. На тај начин повећавамо шансе да програм на крају не ради како треба, јер се при преправљању копираних наредби лако погреши (нпр. нешто заборавимо или помешамо). Такве *copy-paste* грешке се дешавају свима, па и врхунским програмерима, према томе рачунајте да ћете их правити и ви. Писање метода смањује потребу за копирањем и преправљањем, а тиме и шансе да програм не буде исправан.

Друга мана решења без метода је јаснија ономе ко чита програм, него ономе ко га пише. Читалац треба да пажљиво испрати имена променљивих у три ``if-else`` наредбе уместо само једне, да би видео да се логика у њима заиста понавља (онај који је писао програм то наравно зна, а сви други то тек треба да утврде читањем).

|

.. questionnote::

    **Римски запис броја**
    
    Написати програм који учитава цео број и исписује његов римски запис.
    
Знамо да се у римским записима бројева понавља извесна правилност при записивању јединица, десетица и стотина. На пример:

- 8 се пише као 5 + 1 + 1 + 1, то јест као VIII
- 80 се пише као 50 + 10 + 10 + 10, то јест као LXXX
- 800 се пише као 500 + 100 + 100 + 100, то јест као DCCC

Ту правилност можемо да искористимо тако што одговарајућу логику сместимо у метод. Методу ``CifraURimski`` прослеђујемо цифру коју треба записати римским начином, али такође прослеђујемо и како се за ту месну вредност записује јединица, петица и десетка. Тако само једном треба да испрограмирамо логику типа "осмица се пише помоћу петице и три јединице". Тиме поново добијамо краћи и прегледнији програм.

.. activecode:: metodi_rimski_zapis
    :passivecode: true
    :coach:
    :includesrc: _src/metodi/metodi_rimski_zapis.cs

Размислите како би изгледао програм који решава овај задатак без употребе метода.

~~~~

Надамо се да смо вас уверили да писање метода треба увежбавати као и све остало што чини вештину и знање програмирања. Ако је тако, методе ћете убудуће писати и вежбати и када то није тема, пре свега зато што ћете уз помоћ метода писати боље програме.

Следи неколико задтака у којима можете да вежбате употребу метода.

