Знаковни подаци
===============

У приручнику `Увод у програмирање у програмском језику C# <https://petljamediastorage.blob.core.windows.net/root/Media/Default/Kursevi/spec-it/csharpprirucnik.pdf>`_ погледајте поглавље 7.1 (стране 175-178).

~~~~

Подсетимо се најпре укратко онога што смо научили из приручника:

Знаковни тип се у језику *C#* означава са *char*. Знаковну променљиву *c* можемо да декларишемо овако:

.. code-block:: csharp

    char c;

У вредности знаковног типа (карактере) спадају слова, цифре и разни специјални знаци (симболи). Ове вредности се у програмима пишу између апострофа. На пример, следећом наредбом променљивој *c* као вредност додељујемо симбол ``!``. 

.. code-block:: csharp

    char c = '!';

|

Појединачни карактери се могу учитавати помоћу метода *Console.Read()*, али при томе треба имати на уму да овај метод враћа цео број који представља кôд карактера који корисник унесе. Због тога је потребно извршити експлицитну конверзију резултата у карактер.

Исписивање карактера је практично исто као и за друге податке. Тако, следећи програм учитава један карактер и исписује га уз поруку.

.. activecode:: read_write_char_1
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/read_write_char_1.cs

    
Опсег и величина типа *char*
----------------------------

Сваки карактер у језику *C#* заузима два бајта (16 бита) у меморији, што је довољно да се представи :math:`2^{16} = 65536` различитих карактера. 

Међу симболе који се у језику *C#* могу користити као вредности типа *char* спадају слова скоро свих модерних језика. То укључује ћирилична писма, арапско, грчко, грузијско, корејско, индијска и јапанска писма, велики број кинеских симбола итд. Наравно, обухваћена су и сва слова оба српска писма. 

Осим слова, у *C#* карактере спада и велики број специјалних симбола, као што су ови

.. code::

    ± ≤ ≥ ≠ ᑎ ᑐ
    ⅓ ⅔ ⅕ ⅖ ⅗ ⅘ ⅙ ⅚ ⅛ ⅜ ⅝ ⅞
    € ￡ ￥
    ← ↑ → ↓ ↔ ↕ ⭮ ⭯ ⮌ ⮍ ⮎ ⮏ 
    ☺ ☻ ♪ ♫ ♠ ♡ ♢ ♣ ♤ ♥ ♦ ⏰ ⏱ ⏲ ⏳
    ╠ ╡ ╢ ╣ ╤ ╥ ╦ ╧ ╨ ╩ ╪ ╫ ╬ 

и многи други. Ипак, постоје и симболи који се могу појавити и користити у рачунарима а не могу се представити **једним** *C#* карактером (рачунари користе више од 65536 карактера). О томе нешто више у делу о нискама симбола (стринговима). 

|

Врло је вероватно да је ваше програмерско окружење подешено тако да програми са интерфејсом конзолне линије за приказивање симбола у конзолном прозору користе само један бајт по симболу. Пошто један бајт може да садржи само 256 различитих вредности, тако подешено окружење може исправно да прикаже мање од 256 симбола (карактери који одговарају кодовима 0 - 255 нису сви приказиви). Међу карактерима који се могу приказати користећи један бајт, историјски значајнији су они са кодовима од 0 до 127, који чине такозвани *ASCII* скуп карактера (чита се АСКИ, скраћено од *American Standard Code for Information Interchange*). Међу тих 128 карактера је ових 95, који се могу приказати (први је размак):

.. code::

      ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
    @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _
    ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~
    

Проверите да ли је ваше окружење подешено да исправно приказује и друге карактере извршавањем следећег програма:

.. activecode:: write_nj_1
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/write_nj_1.cs

Ако програм не приказује слово Њ, већ неки други симбол (на пример упитник), то значи да се при тренутном подешавању за приказивање користи један бајт по карактеру. Да бисте видели слово Њ, потребно је да програм измените овако:

.. activecode:: write_nj_2
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/write_nj_2.cs

Наредбом *Console.OutputEncoding = System.Text.Encoding.Unicode;* подешавамо начин приказивања симбола у конзолном прозору тако да се сви *C#* карактери могу исправно приказати.

Слично томе, да би програм исправно учитавао унете симболе, потребно је додати и линију 7, која подешава кодирање улазних података:

.. activecode:: read_write_char_2
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/read_write_char_2.cs

Однос типова *char* и *int*
---------------------------

Сваком *C#* карактеру одговара целобројни кôд од 0 до 65535. Језик *C#* допушта комбиновање карактера и бројева у изразима, при чему се уместо карактера у рачунању користе њихови кодови. У том смислу, тип *char* се може схватити као целобројни тип који је ужи (мањег опсега) од типа *int* и у многим ситуацијама он је управо тако и третиран у језику *C#*.

Најчешћи разлог да се карактери уопште појављују у изразима и учествују у рачунању је то што 

- узастопним великим словима енглеске абецеде одговарају узастопни кодови 
- узастопним малим словима енглеске абецеде одговарају узастопни кодови 
- узастопним декадним цифрама одговарају узастопни кодови 

(ова правилност на жалост не важи и за сва наша слова). Тако на пример, наредбом

.. code-block:: csharp

    char c = (char)('A' + 3);

променљивој *c* додељујемо карактер *D*. При сабирању 'A' + 3 долази до имплицитне конверзије карактера 'A' у целобројну вредност која представља кôд овог карактера. Сабирање се обавља као целобројно и резултат је целобројног типа. Овај целобројни резултат може да се експлицитно конвертује (кастује) у карактер, при чему се број тумачи као кôд карактера.

Приликом приказивања податка од пресудне важности је његов тип, па о томе треба водити рачуна. На пример, од наредне три наредбе, прве две исписују број (кôд слова *D*), а само трећа приказује карактер (слово *D*).

.. code-block:: csharp

        Console.WriteLine('A' + 3);
        Console.WriteLine((char)'A' + 3);
        Console.WriteLine((char)('A' + 3));

Слично овоме, израз (char)('d' + 2) има вредност *'f'*, а израз (char)('4' + 3) има вредност '7'. Последњу релацију не треба мешати са сабирањем бројева 4 и 3. Овде се ради о томе да се додавањем броја 3 на кôд карактера '4' добија кôд карактера '7'.

|

Овакво сабирање карактера и бројева се може искористити у разним ситуацијама. Рецимо да је дато питање са понуђеним одговорима, који су означени словима *A*, *B*, *C*, *D*... Ако нам је познато слово које означава изабрани одговор, онда редни број одговора можемо да израчунамо овако:

.. code-block:: csharp

    // променљива odg је типа char и садржи ознаку одговора (велико слово)
    int redniBr = 1 + odg - 'A';

Обрнуто, ако нам је потребно велико слово чији редни број знамо, можемо да га израчунамо овако:

.. code-block:: csharp

    // променљива redniBr је типа int и садржи редни број одговора
    char odg = (char)('A' + redniBr - 1);

Исте изразе можемо да искористимо и у другим ситуацијама, на пример када су колоне неке табеле (као што је шаховска табла) означене словима, па је потребно на основу редног броја колоне израчунати ознаку те колоне или обрнуто.

Претварање малих слова у велика и обрнуто
-----------------------------------------

У језику *C#* постоји метод *char.ToUpper()* који за дато мало слово било којег писма враћа одговарајуће велико слово. Тако, на пример израз *char.ToUpper('л')* има вредност *'Л'*. Ако се у променљивој *sl* типа *char* не налази мало слово, тада је вредност израза *char.ToUpper(sl)* једнака *sl*. Тако писањем наредбе

.. code-block:: csharp

    sl = char.ToUpper(sl);
    
постижемо да уколико се у променљивој *sl* налази мало слово, да се оно замени одговарајућим великим словом, а у противном (ако није мало слово) вредност остаје непромењена. 

Користећи метод *char.ToUpper()* у претходном примеру, можемо да израчунамо редни број неког слова чак и када не знамо да ли је то слово мало или велико:

.. code-block:: csharp

    // променљива odg је типа char и садржи ознаку одговора (било велико или мало слово)
    int redniBr = 1 + char.ToUpper(odg) - 'A';

|

Метод који ради обрнуту ствар, то јест за дато велико слово (било којег писма) враћа одговарајуће мало слово је метод *char.ToLower()*.
И овај метод враћа свој аргумент ако он није велико слово. Овај метод нам између осталог омогућава да одредимо редни број датог слова на још један начин:

.. code-block:: csharp

    // променљива odg је типа char и садржи ознаку одговора (било велико или мало слово)
    int redniBr = 1 + char.ToLower(odg) - 'a';

