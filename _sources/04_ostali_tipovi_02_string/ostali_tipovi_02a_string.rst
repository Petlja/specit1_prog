Текстуални подаци (стрингови, ниске)
====================================

Текстуални подаци, односно стрингови, и до сада су се појављивали у нашим програмима као низови симбола окружени наводницима. На пример, у наредби

.. code-block:: csharp

    Console.WriteLine("Kako se zoves?");

запис ``"Kako se zoves?"`` је један стринг. Тип који означава текстуалне податке је тип ``string``. Ево како можемо да декларишемо променљиву типа ``string`` и да јој доделимо вредност:

.. code-block:: csharp

    string tekst;
    tekst = "Kako se zoves?";

или краће:

.. code-block:: csharp

    string tekst = "Kako se zoves?";

Исписивање вредности променљивих текстуалног типа је једнако једноставно као и за бројеве или знаковне податке

.. code-block:: csharp

    Console.WriteLine(tekst);

док је учитавање стрингова чак једноставније од учитавања података осталих типова, јер метод ``Console.ReadLine()`` управо враћа текст (стринг) који корисник унесе до притиска на тастер *Enter*.

.. code-block:: csharp

    string s = Console.ReadLine();

Метод *Split*
-------------

Када корисник у једном реду уноси два или више података, обично их учитавамо као један стринг, а затим тај стринг накнадно раздвајамо на делове. Један начин да раздвојимо стринг на делове је употреба метода ``Split()``. На пример, ако корисник уноси три цела броја раздвојена по једним размаком, те бројеве можемо да сместимо у целобројне променљиве ``a``, ``b`` и ``c`` на овај начин:

.. code-block:: csharp

    string [] s = Console.ReadLine().Split();
    int a = int.Parse(s[0]);
    int b = int.Parse(s[1]);
    int c = int.Parse(s[2]);

Метод ``Split`` враћа неколико стрингова, то јест низ стрингова. Низовима објеката (па и низовима стрингова) ћемо се бавити касније у овом курсу, па се овде нећемо упуштати у објашњавања свих детаља последњег програмског сегмента. Поменимо само да у овом запису име ``s`` означава низ стрингова, а поједини стрингови у низу су ``s[0]``, ``s[1]`` и ``s[2]``.

Овај поступак за сада треба запамтити као малу програмску целину и употребити када год у једном реду очекујемо више података. 

Да бисмо при оваквом раздвајању стринга на делове добили жељени резултат, важно је да улазни стринг нема размаке на почетку и крају. Треба знати да **сваки унети размак служи као раздвајач**, па у случају да се унесе ``∙1∙∙2∙∙`` (тачке означавају унете размаке), наредбом

.. code-block:: csharp

    string [] s = Console.ReadLine().Split();
    
бисмо добили шест делова: ``s[0]`` би био празан стринг (његова вредност се пише навођењем само почетних и завршних наводника: ``""``), ``s[1]`` би имао вредност ``"1"``, ``s[2]`` би био празан, ``s[3]`` би имао вредност ``"2"``, а ``s[4]`` и ``s[5]`` би такође били празни стрингови.

.. questionnote::

    **Пример - име и презиме** 
    
    Корисник у једном реду уноси редом презиме и име, раздвојене једним размаком. Написати програм који учитава податке и исписује име а затим презиме (са једним размаком између).

Употребићемо метод ``Split`` на исти начин као малопре:

.. activecode:: niske_ime_prezime
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/niske_ime_prezime.cs

У овом примеру смо успут видели да је оператор + дефинисан за стрингове и да значи надовезивање стрингова - операнада. На пример, вредност израза ``"ска" + "ла"`` је стринг ``"скала"``.

Метод ``Split`` можемо да употребимо и са једним или више аргумената. Један од честих начина употребе је да се наведе знак који представља сепаратор (раздвајач) између делова. Ако се раздвајач не наведе, подразумева се да је то размак (запис ``s.Split(' ')`` значи исто што и  ``s.Split()``).

.. questionnote::

    **Пример - збир три броја** 
    
    Корисник у једном реду уноси израз облика *a + b + c*, при чему су *a*, *b* и *c* низови цифара, на пример ``71 + 5 + 123``. Број и распоред размака није битан (може бити било какав). Програм треба да испише збир три унета броја. На пример, ако корисник унесе ``71 + 5 + 123``, програм треба да испише ``199``.

У програму користимо метод ``Split`` са аргументом ``'+'``, што значи да ће унесени ред текста бити растављен на мање стрингове помоћу знака ``'+'`` као раздвајача. Сваки од тих делова (очекујемо три дела) претварамо у целобројну вредност методом ``int.Parse`` (овај метод игнорише размаке на почетку и крају записа целог броја) и затим лако добијамо и исписујемо збир бројева.

.. activecode:: niske_zbir1
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/niske_zbir1.cs


Методи *IndexOf* и *Substring*
------------------------------

Када корисник уноси више података у једном реду (и не само тада), од користи могу бити и методи ``IndexOf`` и ``Substring``. 

Метод ``IndexOf`` служи да врати позицију (редни број, бројећи од 0) првог појављивања задатог симбола. На пример, ``"програм".IndexOf('р')`` враћа ``1``, јер се прво слово ``р`` налази на позицији 1 (слово ``п`` је на позицији 0). Ако не желимо да почнемо тражење симбола од почетка текста, можемо да задамо и позицију од које почиње тражење. На пример, "програм".IndexOf('р', 2) враћа 4, јер је то прва позиција слова ``р`` ако тражење почиње од позиције 2. Постоје и други начини употребе овог метода, али се у њих нећемо упуштати.

Метод ``Substring`` враћа стринг који је део датог стринга, при чему задајемо позицију почетка и дужину тог дела. На пример, ``"програм".Substring(3, 2)`` враћа ``"гр"``, јер је то подстринг датог стринга ``"програм"``, који почиње на позицији 3 и има дужину 2. 

Дужину дела који издвајамо не морамо да наведемо, а у том случају се подразумева да се узима део до краја полазног стринга. На пример, ``"програм".Substring(3)`` враћа ``"грам"``, јер је то подстринг од позиције 3 до краја стринга ``"програм"``. 

.. questionnote::

    **Пример - збир са знаком =** 
    
    Корисник у једном реду уноси израз облика *a + b + c =*, при чему су *a*, *b* и *c* низови цифара, на пример ``27 +  3+  5 =``. Број и распоред размака није битан. Програм треба да испише збир три унета броја. На пример, ако корисник унесе ``27 +  3+  5 =``, програм треба да испише 35.

Користећи метод ``IndexOf``, можемо да одредимо позиције знакова ``+`` и ``=``. Затим делове улазног стринга који садрже бројеве издвајамо као подстрингове методом ``Substring``. На крају, као и у претходном примеру, стрингове који садрже бројеве претварамо у целобројне вредности, а затим израчунавамо и приказујемо збир.

.. activecode:: niske_zbir2
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/niske_zbir2.cs

Методи *ToLower* и *ToUpper*
----------------------------

У случају да нам је потребно да сва слова једног стринга претворимо у велика, користимо метод ``ToUpper()``. На пример, вредност израза ``"Нови Сад".ToUpper()`` је стринг ``"НОВИ САД"``.

Када је потребно сва слова стринга претворити у мала слова, користимо метод ``ToLower()``. На пример, вредност израза ``"Нови Сад".ToLower()`` је стринг ``"нови сад"``.

.. questionnote::

    **Пример - прва реч** 
    
    Написати програм који за унету реченицу исписује исту реченицу, али тако да прва реч буде исписана свим великим словима.

Имена променљивих су таква да програм није потребно детаљно коментарисати. Приметимо само да смо за одређивање остатка реченице користили метод ``Substring`` без задавања дужине подстринга, што значи да у подстринг који метод враћа улазе сви симболи до краја стринга.

.. activecode:: niske_prva_rec_velikim
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/niske_prva_rec_velikim.cs


Свосјтво *Length*
-----------------

Дужину стринга добијамо помоћу својства ``Length``, које се може употребити овако:

.. code-block:: csharp

    string s = "Здраво";
    Console.WriteLine(s.Length);

Својство ``Length`` враћа број карактера од којих се дати стринг састоји. У датом примеру, другом наредбом се исписује број 6, јер је то дужина стринга "Здраво".


Број симбола и дужина стринга
'''''''''''''''''''''''''''''

За крај ове лекције, желимо да разјаснимо једну необичну особину језика *C#*, **са којом се нећете често сретати**, али када на њу наиђете, може да буде прилично збуњујућа. Ради се о томе да оно што интуитивно схватамо као симбол или карактер није сасвим исто што и карактер у језику *C#*, односно елемент типа ``char``.

Када смо говорили о опсегу типа ``char``, поменули смо да се за представљање карактера у језику *C#* користи 2 бајта, што омогућава представљање :math:`2^{16} = 65536` различитих карактера. Симболи који нису међу тих 65536 могућих вредности типа ``char`` не могу да се доделе променљивој типа ``char``, али могу да се појаве у стринговима. Тако долазимо до необичних исхода, као у следећем програму:

.. activecode:: niske_simbol_duzine_2
    :passivecode: true
    :coach:
    :includesrc: _src/sekvencijalni/niske_simbol_duzine_2.cs

Програм исписује број 2, што значи да стринг који се састоји од једног симбола има дужину 2. Из овог примера се види да се неки симболи представљају са два карактера. Заиста, ако напишемо наредбу 

.. code-block:: csharp

    char c = '🤩'; 

добијамо грешку ``Error CS1012: Too many characters in character literal``, исто као да смо написали 

.. code::

    char c = 'AB';

До ове необичне особине језика *C#* је дошло због компромиса између начина кодирања и потребе за ефикасношћу. 

Начин кодирања симбола који се користи у језику *C#* зове се *utf-16*, скраћено од *16-bit Unicode Transformation Format*. У овом начину кодирања немају сви симболи исту дужину - за неке симболе је потребно 2 бајта, а за неке 4. Са друге стране, за ефикасно баратање подацима је веома важно да сваки тип података има унапред одређену дужину. Пошто је за симболе који се најчешће користе довољно по два бајта, било би нерационално резервисати за сваки симбол по 4 бајта. Тако су творци језика *C#* одлучили да се за податак типа ``char`` користи два бајта. Последица је да неки симболи не могу да да се представе као један *C#* карактер, већ је потребно користити два "карактера" (у ствари, две вредности типа ``char``). При томе се садржај (кôд) првог од таква два "карактера" не може користити самостално, него тај садржај добија смисао само у пару са другим карактером.

.. comment

        Функције ``s.Trim()``, ``s.Replace()``, ``s.Find()`` ?
        
