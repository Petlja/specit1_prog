Листе и ефикасност
==================

Видели смо да класа *List* садржи велики број метода који нам омогућавају да програме пишемо брже и лакше, као и да ти програми буду краћи и лакши за раузмевање другима.

Познавање функционалности готових метода је свакако први корак, али за квалитетну употребу то није довољно - важно је бар начелно разумети на који начин ови методи раде, да бисмо избегли непримерену употребу. 

Да би било сасвим јасно о чему је реч, послужићемо се примерима. 

**Избацивање елемената**

Рецимо да је потребно из дате листе *a* избацити само елемент на позицији 4. То можемо да урадимо пишући *a.RemoveAt(4);*. Оно што се при томе догађа "испод хаубе" је да се сви елементи од позиције 5 до краја листе премештају за једно место на лево и на крају се својство *Count* смањује за 1. Није дошло до реалокације, али скоро иста цена је плаћена због преписивања потенцијално великог броја података. На жалост, не можемо да избацимо један елемент из листе на начин ефикаснији од овога.

Претпоставимо сада да је потребно из дате листе целих бројева избацити све негативне бројеве. Један начин да ово урадимо је

.. code-block:: csharp

    int i = 0;
    while (i < a.Count)
        if (a[i] < 0) a.RemoveAt(i);
        else i++;

Испоставља се да је ово врло лош начин да обавимо задатак. Замислимо листу од милион елемената у којој су првих сто хиљада негативни. На наведени начин би се осталих 900000 елемената преписивало сто хиљада пута (сваки пут када извршимо *a.RemoveAt(i)*), што је укупно деведесет милијарди преписивања.

Алтернативно, исти посао можемо да обавимо и овако:

.. code-block:: csharp

            int n = 0;
            for (int i = 0; i < a.Count; i++)
                if (a[i] >= 0)
                {
                    a[n] = a[i];
                    n++;
                }

            a.RemoveRange(n, a.Count - n);

На овај начин елементи који нису негативни се преписују само једном! У примеру са милион елемената од којих су првих сто хиљада негативни то би било равно сто хиљада пута мање преписивања (уштеда је утолико већа што је више негативних бројева). Приметимо да је извршавање метода *RemoveRange* после петље веома брзо, јер не захтева никакво премештање елемената, већ само смањивање вредности својства *Count*.

Наравно, кратак и једноставан начин је да користимо метод *RemoveAll* са одговарајућим предикатом:

.. code-block:: csharp

    a.RemoveAll(x => x < 0);

У наставку је програм који мери време рада ова три поступка за избацивање негативних елемената из листе. Измерено време за први метод је било око минут, а други и трећи по неколико милисекунди. Због истовременог извршавања и других процеса на рачунару ова времена не могу бити сасвим прецизна и не могу да послуже да се утврди који од два брза начина је ефикаснији. Што се тиче првог поступка, закључак је више него јасан: елементе не треба избацивати из листе на такав начин!

.. activecode:: nizovi_izbacivanje_iz_liste_efi
    :passivecode: true
    :coach:
    :includesrc: _src/nizovi/nizovi_izbacivanje_iz_liste_efi.cs

|

**Убацивање елемената**

Слично важи и за убацивање елемената у листу. Приликом сваког убацивања једног елемента, прво се сви елементи почев од позиције на коју се убацује (па до краја листе) померају за једну позицију у десно да би се направило место за нови елемент, а затим се уписује нови елемент. Код листи нема другог начина, па зато и готови методи морају да раде на овај или врло сличан начин. Ако је уз ово потребна и реалокација, она је додатни корак који претходи описаном.

Када на више места у листи треба убацити неке елементе, уз мало додатног труда то се често може урадити тако да се постојећи елементи листе премештају само једном, или се бар број премештања може значајно смањити.

Нека је дата листа целих бројева и нека је потребно сваку нулу у листи заменити двема узастопним нулама.

У програму који следи овај захтев је испуњен на три различита начина. 

- У методу *f1* код сваке нађене нуле убацујемо још једну нулу позивом *a.Insert(i, 0);* При сваком таквом убацивању се сви наредни елементи премештају.
- У методу *f2* прво пребројимо нуле, затим на крај листе додамо потребан број елемената (било које вредности, битно је само да се заузме простор), а онда сваки елемент премештамо само једном уписујући успут додатне нуле где је потребно. 
- У методу *f3* формирамо нову листу у коју редом преписујемо елементе дате листе, с тим да сваку нулу уписујемо два пута. 

Очекујемо да је метод *f1* значајно спорији од остала два због вишеструког премештања постојећих бројева. Да ово не би остала само претпоставка, измерили смо време извршавања и ових метода за низ од милион нула.

Методу *f1* је било потребно **преко три минута**, док су методи *f2* и *f3* завршили са радом за **пар стотинки секунде**. Ови бројеви говоре сами за себе.


.. activecode:: nizovi_ubacivanje_u_listu_efi
    :passivecode: true
    :coach:
    :includesrc: _src/nizovi/nizovi_ubacivanje_u_listu_efi.cs

~~~~

У помињаним методима за убацивање или избацивање елемената у и из листе нема ничег погрешног. Они добро обављају **посао за који су написани** и нису лоши сами по себи, лоше су само неке употребе тих метода. На пример, једнократно додавање елемента у дугачак низ се најбоље изводи методом *Insert*. Међутим, овакве методе треба користити са разумевањем и извесним опрезом. Видели смо да када треба додати веома велики број елемената на разна места у листи, и те како вреди размислити о ефикаснијем решењу, у коме ће број премештања елемената листе бити што мањи. То се може постићи на разне начине, укључујући и писање сопствених метода, а као принцип треба усвојити следећа правила:

- тежити томе да се избацивање и додавање елемената обавља само на крају листе (или што ближе крају листе), 
- више операција појединачног брисања или убацивања заменити једном операцијом групног брисања или убацивања кад год је то могуће


Поред напомена учињених овде, такође треба имати на уму да уколико проблем који решавамо намеће потребу да се елементи често убацују у колекцију или избацују из ње, можда листа и није најбољи начин чувања свих тих вредности. О другим структурама података које могу да буду знатно ефикасније у таквим ситуацијама биће речи у старијим разредима.

