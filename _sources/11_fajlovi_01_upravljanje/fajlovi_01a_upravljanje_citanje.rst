Управљање фајловима
===================

Фајл, односно датотеку можемо да окарактеришемо као именовани део меморије на диску рачунара. У фајловима се чувају разни подаци, попут видео и аудио записа, слика, докумената, програма, итд. а у текстуалним фајловима се налази текст. 

Методи за рад са фајловима се налазе у именском простору ``System.IO``. Да бисмо једноставније користили те методе, потребно је да на почетку нашег програма најавимо коришћење именског простора ``System.IO``:

.. code-block:: csharp

    using System.IO;

Поред тога, многи методи за манипулисање фајловима користе интерфејс ``IEnumerable`` (од енгл. *enumerable* - набројив), који представља колекцију елемената одређеног типа (у овом контексту најчешће колекцију стрингова). Због тога је потребно укључити и именски простор ``System.Collections.Generic`` у којем је дефинисан интерфејс ``IEnumerable``.

.. code-block:: csharp

    using System.Collections.Generic;

Поменимо за сада само да од сваке набројиве колекције може да се формира листа или низ, што смо и до сада чинили без истицања. На пример, за стринг ``s`` метод ``s.Reverse()`` враћа набројиву колекцију карактера од краја ка почетку стринга, па низ тих карактера можемо да добијемо као ``s.Reverse().ToArray()``. Дакле, за сада ћемо набројиве колекције посматрати као да су низови (тј. нешто што се лако претвара у низ), а ускоро ћемо упознати и једну њихову важну предност у односу на низове.

Претрага
--------

Фајлови на диску су организовани у систем фајлова (*file system*), који се састоји од фолдера, у којима се могу налазити други фолдери и фајлови. На тај начин фолдери образују хијерархију која нам омогућава да разврстамо фајлове у мање групе, које затим даље организујемо како нам одговара.

Када нисмо сигурни где се налази фајл који нам је потребан, оперативни систем нам омогућава да претражимо диск или неки његов део и пронађемо жељени фајл. Исту могућност имамо и у програмима које пишемо. На располагању су нам следећи методи:

.. code-block:: csharp

    Directory.EnumerateFileSystemEntries(string putanja, string maska, SearchOption opt);
    Directory.EnumerateDirectories(string putanja, string maska, SearchOption opt);
    Directory.EnumerateFiles(string putanja, string maska, SearchOption opt);

Метод ``EnumerateDirectories`` враћа колекцију имена свих фолдера (директоријума) који се налазе унутар задатог фолдера. Слично томе, метод ``EnumerateFiles`` враћа колекцију имена свих фајлова унутар задатог фолдера, метод ``EnumerateFileSystemEntries`` враћа колекцију у којој се налазе и имена фајлова и имена фолдера унутар задатог фолдера, тј. колекцију која је унија претходне две.

Ови методи у наведеном облику имају исте параметре, па ћемо параметре објаснити истовремено за сва три метода.

- Параметар ``putanja`` је путања до фолдера чији садржај желимо да добијемо, нпр. ``"c:/programi/scharp"``. За раздвајање имена подфолдера у стрингу који садржи путању се у оперативном систему *Windows* много чешће користи обрнута коса црта (*backslash*, симбол ``\``), али због њеног специјалног значења у стринговима, треба је писати по два пута, као у ``"c:\\programi\\scharp"``.
- Параметар ``maska`` је опис коме треба да одговарају имена постојећих фалјова и фолдера. На пример, маска ``"*.txt"`` описује фајлове са екстензијом ``.txt``, маска ``"a*.*"`` описује фајлове и фолдере чије име почиње на слово `a` итд.
- Параметар ``opt`` је набројивог типа дефинисаног у библиотеци ``System.IO.`` и има само две могуће вредности. Вредност ``SearchOption.TopDirectoryOnly`` значи да се претражује само фолдер чија путања је наведена као први параметар, тј. у колекцији ће се наћи само они фајлови/фолдери који се налазе непосредно у наведеном фолдеру. Вредност ``SearchOption.AllDirectories`` значи да се претражују сви подфолдери задатог фолдера, тј. читаво подстабло тог фолдера.

Пример - Претрага фолдера
'''''''''''''''''''''''''

Испробајте следећи програм на свом рачунару, да бисте боље разумели како раде методи о којима је било речи. Наравно, потребно је да унестете путању до фолдера који постоји на вашем рачунару. Можете такође и да у коду програма промените маску која описује фајлове које желите да нађете (на пример, као маску можете да задате и тачно име фајла).

.. activecode:: pretraga_foldera
    :passivecode: true
    :coach:
    :includesrc: _src/fajlovi/pretraga_foldera.cs

Провера постојања
-----------------

Неки програми прихватају од корисника путању до фајла са којим треба нешто урадити. У случају да корисник унесе погрешну путању и програм покуша да приступи непостојећем фајлу, може доћи до грешке у извршавању програма (програм пукне). Један начин да предупредимо такав сценарио је да проверимо да ли постоји фајл који је корисник навео. За такве провере можемо да користимо следеће методе:

- ``bool File.Exists(string putanja)`` Ако постоји фајл на задатој путањи (и корисник који је покренуо програм има право приступа том фајлу), функција враћа ``true``, а у супротном ``false``.
- ``bool Directory.Exists(string putanja)`` Ако постоји фолдер на задатој путањи функција враћа ``true``, а у супротном ``false``.

Пример - Провера постојања
''''''''''''''''''''''''''

Да бисте потврдили разумевање, можете да испробате и ове методе на свом рачунару (не заборавите да наведете одговарајућу, тј. постојећу путању).

.. activecode:: postojanje_fajla_i_foldera
    :passivecode: true
    :coach:
    :includesrc: _src/fajlovi/postojanje_fajla_i_foldera.cs

Манипулација фајл системом
--------------------------

Неке од метода који се најчешће употребљавају у манипулацији фајловима и фолдерима смо већ поменули. Поред поменутих, библиотека ``System.IO`` има још много корисних метода за манипулацију фајловима и фолдерима (по правилу сваки метод у више верзија). Поменућемо сасвим укратко још само неке од њих, а више информација о овим и другим методима се врло лако може наћи онлајн.

- ``void Directory.CreateDirectory(string putanja)`` - фолдер са наведеном путањом (ако већ не постоји). По потреби претходно креира и надфолдере задатог фолдера.
- ``void File.Copy(string original, string kopija, bool pregazi)`` - креира фајл на путањи ``kopija`` истоветан са фајлом на путањи ``original`` (одредишни фолдер треба да постоји, у противном програм пукне). Ако одредишни фајл већ постоји, трећим параметром се задаје да ли тај претходни фајл може (треба) да буде прегажен.
- ``void File.Delete(string putanja)`` - брише фајл са наведеном путањом. **Опрез:** ако испробавате овај метод, користите фајл који стварно желите да обришете.
- ``Directory.Delete(string putanja, bool rekurzivno)`` - брише фолдер са наведеном путањом. Другим параметром се дефинише понашање метода ако задати фолдер има подфолдере (``true`` значи брисање подфолдера и свега што је у њима). **Опрез:** ако испробавате овај метод, користите фолдер који стварно желите да обришете.
- ``string Directory.GetCurrentDirectory()`` - враћа путању до текућег (активног) фолдера, тј. фолдера из ког је покренут програм.
- ``void Directory.SetCurrentDirectory(string putanja)`` - прелази у задати фолдер, тј. поставља га као текући (активан).
- ``DirectoryInfo Directory.GetParent(string putanja)`` - враћа структуру са информацијама о родитељском фолдеру. Структуром ``DirectoryInfo`` се нећемо овде бавити, осим што ћемо је конвертовати у стринг методом ``.ToString()`` да бисмо добили путању до родитељског фодлера.

Пример - Копирање фајла
'''''''''''''''''''''''

Следећи метод може да буде користан ако желимо да копирамо постојећи фајл у фолдер који још није креиран.

.. code-block:: csharp

    static void Kopiraj(string original, string kopija)
    {
        string folderKopije = Directory.GetParent(kopija).ToString();
        if (!Directory.Exists(folderKopije))
        {
            Directory.CreateDirectory(folderKopije);
        }
        File.Copy(original, kopija, true);
    }
