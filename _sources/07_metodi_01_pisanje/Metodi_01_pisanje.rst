Писање статичких метода
=======================

У приручнику `Увод у програмирање у програмском језику C# <https://petljamediastorage.blob.core.windows.net/root/Media/Default/Kursevi/spec-it/csharpprirucnik.pdf>`_ погледајте поглавља 5.1 - 5.4 (стране     112-120).

~~~~

Поновимо укратко најважније појмове у вези са писањем статичких метода:

Метод се састоји од **заглавља** и **тела**.

У **заглављу** статичког метода се након речи ``static`` редом наводи:

- Какву врсту податка израчунава метод (ког типа је податак који метод враћа као резултат);
- Како се метод зове;
- Шта је од података методу потребно да би могао да обави посао за који је написан. Ови подаци се наводе између заграда и називају се аргументи метода. Аргументи се раздвајају зарезима, а за сваки аргумент се наводи тип и име. Ако методу нису потребни никакви подаци, листа аргумената је празна па се иза имена метода наводи само пар заграда ()

На пример, у заглављу 

.. code-block:: csharp

    static double Stepen(double x, int n)
    
наведено је да метод израчунава и враћа реалан број, да се метод зове ``Stepen`` и да има два аргумента: реалан број ``x`` и цео број ``n``. 

**Тело** метода је низ наредби које се пишу између витичастих заграда. Ако метод враћа вредност, последња наредба тела метода мора да буде наредба ``return``, иза које се наводи израз чија вредност се враћа као резултат.

На пример, метод којим се израчунава :math:`x^n` може да се напише овако:

.. code-block:: csharp

    static double Stepen(double x, int n)
    {
        double rez = 1;
        for (int i = 0; i < n; i++)
            rez *= x;
        return rez;
    }
    

Метод не мора да врати вредност. Ако метод не враћа вредност, уместо типа резултата пишемо реч ``void`` (то значи да метод не враћа ништа). На пример, следећи метод исписује табелу која представља календар за један месец.

.. code-block:: csharp

    // Metod ispisuje tabelu koja predstavlja kalendar za mesec 
    // koji ima n dana, a ciji prvi dan je nedelja ako je d = 0, 
    // ponedeljak ako je d = 1, ..., subota ako je d = 6
    static void IspisiMesec(int d, int n) 
    {
        int i;
        Console.WriteLine(" ne po ut sr ce pe su");
        for(i = 0; i < d; i++)
            Console.Write(" ");
            
        for(i = 1; i <= n; i++) 
        {
            if (i <= 9) 
                Console.Write(" ");
            else 
                Console.Write("  ");

            Console.Write(i);
            if((i + d) % 7 == 0)
                Console.WriteLine();
        }
        Console.WriteLine();
    }
    
Да би метод који не враћа вредност нечему служио, он треба да ради нешто друго, јер у противном не бисмо имали начина да приметимо да је такав метод уопште извршен. На пример, метод ``IspisiMesec`` исписује нешто на екран. Све што можемо да приметимо као резултат рада метода, а није враћено као резултат, називамо **пропратни ефекат** (енгл. *side effect*, каже се и споредни, или бочни ефекат). Можемо рећи да је главни задатак метода који не враћа вредност да произведе неки пропратни ефекат. 

Сваки пропратни ефекат треба јасно истаћи и нагласити (поред осталог и самим именом метода), да би кôд био што јаснији свакоме ко га чита. Скривени пропратни ефекти (као што је измена вредности које се налазе ван локалног окружења функције) могу да учине програм мање јасним, а писање нејасних програма је веома лоша пракса. Зато неочекиване и тешко уочљиве пропратне ефекте треба избегавати.

~~~~

Из ових примера видимо да:

- метод може да има више аргумената који могу, а не морају да буду истог типа;
- тип резултата метода може да буде било који стандардни тип (``double``, ``int``, ``bool``, ``char``, ``string`` итд.), као и сви други типови о којима ћемо говорити касније; 
- метод не мора да враћа резултат и тада уместо типа резултата пишемо ``void``;
- метод може да има своје локалне променљиве;
- метод који не враћа резултат не мора да садржи ``return`` наредбу; такав метод се завршава када се изврше све наредбе наведене у методу;
- чим наиђе на наредбу ``return``, рачунар прекида са извршавањем метода и враћа се у део програма одакле је метод био позван;